<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Corn Park</title>
    <link>https://www.nicecorn.com/posts/</link>
    <description>Recent content in Posts on Corn Park</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hant</language>
    <copyright>Corn Huang</copyright>
    <lastBuildDate>Mon, 25 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.nicecorn.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>用 CSS 实现三角符号</title>
      <link>https://www.nicecorn.com/posts/css/%E7%94%A8-css-%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/css/%E7%94%A8-css-%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7/</guid>
      <description>记忆口诀：盒子宽高皆为 0，三面边框皆透明。
div:after { position: absolute; width: 0px; height: 0px; content: &amp;#39;&amp;#39;; border-right: 100px solid transparent; border-top: 100px solid #ff0; border-left: 100px solid transparent; border-bottom: 100px solid transparent; } </description>
    </item>
    
    <item>
      <title>闭包</title>
      <link>https://www.nicecorn.com/posts/javascript/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E9%97%AD%E5%8C%85/</guid>
      <description>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使是函数在当前词法作用域外执行。
下面这个例子，函数 bar 在作为返回值返回后，在自己定义的词法作用域之外执行。
function foo() { const a = &amp;#39;hello&amp;#39;; function bar() { console.log(a); } return bar; } const baz = foo(); baz(); // hello 应用 防抖与节流</description>
    </item>
    
    <item>
      <title>模块化</title>
      <link>https://www.nicecorn.com/posts/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description> CommonJS：主要是 Node.js 使用，通过 require 同步加载模块，exports 导出内容。 AMD：主要是浏览器端使用，通过 define 定义模块和依赖，require 异步加载模块。 CMD：主要是浏览器端使用，和 AMD 类似，通过 require 异步加载模块，exports 导出内容。 UMD：通用模块规范，是 CommonJS 和 AMD 的融合，是跨平台的解决方案。 ESM：官方模块化规范，现代浏览器原生支持，通过 import 异步加载模块，export 导出内容。 </description>
    </item>
    
    <item>
      <title>类和类继承</title>
      <link>https://www.nicecorn.com/posts/javascript/%E7%B1%BB%E5%92%8C%E7%B1%BB%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E7%B1%BB%E5%92%8C%E7%B1%BB%E7%BB%A7%E6%89%BF/</guid>
      <description>题目 要求写一个动物类，有速度和名字的属性；给两个方法，一个为跑，一个为停止。 要求写一个兔子子类，继承动物类；给一个方法为藏起来。 ES6 class Animal { constructor(name) { this.speed = 0; this.name = name; } run(speed) { this.speed = speed; console.log(`${this.name} 跑的时速为 ${this.speed}`); } stop() { this.speed = 0; console.log(`${this.name} 停止`); } } class Rabbit extends Animal { hide() { console.log(`${this.name} 藏起来了`); } } ES5 function Animal(name) { this.name = name; this.speed = 0; } Animal.prototype.run = function (speed) { console.log(`${this.name} 跑的时速为 ${this.speed}`); }; Animal.prototype.stop = function () { this.</description>
    </item>
    
    <item>
      <title>数组去重</title>
      <link>https://www.nicecorn.com/posts/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      <description>filter + Object function unique(array) { let container = {}; return array.filter((item) =&amp;gt; container.hasOwnProperty(item) ? false : (container[item] = true), ); } filter + indexOf function unique(array) { return array.filter((item, index) =&amp;gt; array.indexOf(item) === index); } Set function unique(array) { return [...new Set(array)]; } </description>
    </item>
    
    <item>
      <title>手写最简静态资源服务器</title>
      <link>https://www.nicecorn.com/posts/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/1.-%E6%89%8B%E5%86%99%E6%9C%80%E7%AE%80%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/1.-%E6%89%8B%E5%86%99%E6%9C%80%E7%AE%80%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>一个简单的网页 在开始部署一个静态资源服务器之前，我们需要先写一个简单的网页供浏览。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt; hello, world &amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; HTTP HTTP 即超文本传输协议，是一个用于传输超文本文档（例如 HTML）的应用层协议。客户端打开一个连接以发送请求，然后等待直到收到服务器响应。最简部署即客户端向服务器发送一个 HTML 文件请求，服务器响应一段 HTML 资源。
在浏览器中访问任意网页，可以自行查看网页的 HTTP 请求和响应报文。
最简静态资源服务器：字符串 作为前端，我们使用 node 来搭建静态资源服务。该服务中，监听 3000 端口，在响应体中返回上文的网页。
首先以字符串返回响应。
在 node 中，写服务端的最重要模块为 node:http。通过 node: 前缀，可以指明其为内部模块，避免 node 内置模块与第三方模块的命名冲突。
const http = require(&amp;#39;node:http&amp;#39;); 通过 http.createServer 可以向外提供 HTTP 服务。res.end() 可以设置 HTTP 报文的响应体。我们先简单响应一个字符串。
const server = http.</description>
    </item>
    
    <item>
      <title>水平垂直居中常见方法</title>
      <link>https://www.nicecorn.com/posts/css/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/css/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</guid>
      <description>文本垂直居中 设置 text-align: center。
元素垂直居中 利用 calc 使用 absolute 定位，已知盒子自身宽高，利用 calc 计算偏移量进行定位。
div { position: absolute; width: 200px; height: 400px; left: calc((100% - 200px) / 2); top: calc((100% - 400px) / 2); background: yellowgreen; } 利用 margin-auto 使用 absolute 定位，已知盒子自身宽高，给定四个方向的定位为 0，利用 margin 定位。
div { width: 200px; height: 400px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; background: skyblue; } 利用 margin 负值 使用 absolute 定位，已知盒子自身宽高，给定 top 和 left 为 50%，将 margin 的对应方向的负值设为其一半来定位。</description>
    </item>
    
    <item>
      <title>计算属性与方法、watch 的异同</title>
      <link>https://www.nicecorn.com/posts/vue/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95watch-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95watch-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>计算属性缓存 vs 方法 在 Vue 中，调用一个函数可能也会获得到和计算属性相同的结果。
当我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的。不同之处在于，计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。只要原变量不改变，无论访问多少次计算属性都会立即返回先前的计算结果，而不用重复执行 getter 函数。
这也意味着下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖：
const now = computed(() =&amp;gt; Date.now()); 相比之下，方法调用总是会在重渲染发生时再次执行函数。
什么情况下需要缓存？如果有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，会重复执行非常多次 list 的计算函数。然而这实际上没有必要。如果确定不需要缓存，那么也可以使用方法调用。
计算属性 vs 侦听器 计算属性允许我们声明性地计算推导值。然而，在有些情况下，为了应对一些状态的变化，我们需要运行些「副作用」：例如更改 DOM，或者根据异步操作地结果，去修改另一处的状态。</description>
    </item>
    
    <item>
      <title>生命周期钩子</title>
      <link>https://www.nicecorn.com/posts/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</guid>
      <description>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据帧听、编译模板、挂载实例到 DOM 以及数据改变时更新 DOM。在此过程中，它也会运行称为生命周期钩子的函数，让开发者有机会在特定阶段添加自己的代码。
注册周期钩子 例如，onMounted 钩子可以在组建完成初始渲染并创建 DOM 节点后运行代码。
&amp;lt;script setup&amp;gt; import { onMounted } from &amp;#39;vue&amp;#39; onMounted(() =&amp;gt; { console.log(`the component is now mounted.`); }) &amp;lt;/script&amp;gt; 还有一些其他的钩子，会在实例生命周期的不同阶段被调用，最常用的是 onMounted、onUpdated 和 onUnmounted。
当调用 onMounted 时，Vue 会自动将注册的回调函数与当前活动组件实例相关联。这要求钩子在组件设置时同步注册，请不要：
setTimeout(() =&amp;gt; { onMounted(() =&amp;gt; { // 这将不会正常工作 }); }, 100); onMounted() 也可以放在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup()。
生命周期图示 </description>
    </item>
    
    <item>
      <title>伪类和伪元素</title>
      <link>https://www.nicecorn.com/posts/css/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/css/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</guid>
      <description>伪类 伪类是用来添加一些选择器的特殊效果。
伪类语法 selector:pseudo-class { property: value; } 在 CSS 类中：
selector.class:pseudo-class { property: value; } anchor 伪类 可以用伪类来定义链接的不同状态。
a:link { color: #ff0000; } /* 未访问的链接 */ a:visited { color: #00ff00; } /* 已访问的链接 */ a:hover { color: #ff00ff; } /* 鼠标划过链接 */ a:active { color: #0000ff; } /* 已选中的链接 */ 注意：
a:hover 必须被置于 a:link 和 a:visited 之后才是有效的。 a:active 必须被置于 a:hover 之后才是有效的。 伪类的名称不区分大小写。 伪类结合 CSS 类 伪类可以与 CSS 类结合使用：
a.red:visited { color: #ff0000; } :first-child 伪类 :first-child 伪类用来选择父元素的第一个子元素。</description>
    </item>
    
    <item>
      <title>条件渲染</title>
      <link>https://www.nicecorn.com/posts/vue/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</guid>
      <description>v-if vs v-show v-if 真实地按照条件渲染，因为它确保条件区块内的事件监听器和子组件都会在切换时被销毁与重建。
v-if 是懒加载的，如果在初次渲染时条件值为 false，则不会做任何事，直到条件首次变为 true 时才会渲染。
v-show 则无论初始条件如何，元素始终会被渲染，仅作 CSS Class 的切换。
总结：v-if 在首次渲染时的切换成本比 v-show 更高。因此需要非常频繁切换时 v-show 会更好，而运行时不常改变的时候 v-if 更合适。
v-if vs v-for 当 v-if 和 v-for 位于同一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名：
&amp;lt;!-- 这会抛出一个错误，因为属性 todo 此时 没有在该实例上定义 --&amp;gt; &amp;lt;li v-for=&amp;#34;todo in todos&amp;#34; v-if=&amp;#34;!todo.isComplete&amp;#34;&amp;gt; {{ todo.name }} &amp;lt;/li&amp;gt; 当需要同时使用时，在外新包装一层 &amp;lt;template&amp;gt; 并在其上使用 v-for：
&amp;lt;template v-for=&amp;#34;todo in todos&amp;#34;&amp;gt; &amp;lt;li v-if=&amp;#34;!todo.isComplete&amp;#34;&amp;gt; {{ todo.name }} &amp;lt;/li&amp;gt; &amp;lt;/template&amp;gt; </description>
    </item>
    
    <item>
      <title>防抖与节流</title>
      <link>https://www.nicecorn.com/posts/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</guid>
      <description>防抖 debounce 基本概念 debounce(fn, timeout)
自最近触发一次后，延迟 timeout 时间调用 fn。
应用场景 调整页面的大小 验证表单时控制请求次数 防止表单多次提交 编写代码 假设一个场景，点击按钮后提交表单数据。为防止表单多次提交，设置点击按钮后延迟 2000ms 提交，自最近一次触发后再延迟提交。
debounce 函数中，接收两个参数，第一个参数为执行防抖的函数，第二个参数为防抖的延迟时间。将计时器记为 timer，每次执行函数之前清除之，则达到每次触发函数时都重新计时的效果。
在执行防抖的函数中执行 console.log(this)，发现其指向 Windows。这时我们可以使用 apply 来把 this 的指向改变。
const button = document.getElementById(&amp;#39;button&amp;#39;); function addOne() { console.log(&amp;#39;add one&amp;#39;); console.log(Date()); } function debounce(fn, timeout) { let timer; return function () { clearTimeout(timer); timer = setTimeout(() =&amp;gt; { fn.apply(this, arguments); }, timeout); }; } button.addEventListener(&amp;#39;click&amp;#39;, debounce(addOne, 2000)); 总而言之，防抖是在不断的操作中最终只执行一次的提高性能的方法。
节流 throttle 基本概念 throttle(fn, timeout)
每 timeout 时间内只调用一次 fn。</description>
    </item>
    
    <item>
      <title>实现布局</title>
      <link>https://www.nicecorn.com/posts/css/%E5%AE%9E%E7%8E%B0%E5%B8%83%E5%B1%80/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/css/%E5%AE%9E%E7%8E%B0%E5%B8%83%E5%B1%80/</guid>
      <description>两栏布局 现有 DOM 结构：
&amp;lt;div class=&amp;#34;outer&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt;left&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt;right&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 利用浮动实现 将左边元素宽度固定并设置为 float: left，将右边元素的 margin-left 设置为左边元素的固定宽度。右边元素的 width 默认为 auto，所以右边宽度会自动撑满父元素。
.outer { height: 100px; background-color: aqua; } .left { float: left; width: 200px; height: 100%; border-color: brown; } .right { margin-left: 200px; height: 100%; background-color: yellowgreen; } 再利用浮动实现 同样利用浮动，将左边元素宽度固定并设置为 float: left，将右边元素设置为 overflow: hidden。右边元素触发 [[面试/CSS/块格式化上下文]]，由于 BFC 的区域不会与浮动元素发生重叠，所以两侧不会重叠。
.outer { height: 100px; background-color: aqua; } .left { float: left; width: 200px; height: 100%; border-color: brown; } .</description>
    </item>
    
    <item>
      <title>组合选择符</title>
      <link>https://www.nicecorn.com/posts/css/%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E7%AC%A6/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/css/%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E7%AC%A6/</guid>
      <description>CSS 组合选择符描述了两个选择器之间的关系。
在 CSS 中包含四种组合方式：
后代选择器，以空格 分割 子元素选择器，以大于号 &amp;gt; 分割 相邻兄弟选择器，以加号 + 分割 普通兄弟选择器，以波浪号 ~ 分割 后代选择器 后代选择器用于选取某元素的后代元素。
如选择在 &amp;lt;div&amp;gt; 中的 &amp;lt;p&amp;gt;。
div p { background-color: yellow; } 子元素选择器 子元素选择器只能选择作为某元素直接或一级子元素的元素。
如选择 &amp;lt;div&amp;gt; 中的所有直接子元素 &amp;lt;p&amp;gt;。
div &amp;gt; p { backgroud-color: yellow; } 相邻兄弟选择器 相邻兄弟选择器选择紧接在另一元素后的元素，且两者有共同父元素。
如选择所有位于 &amp;lt;div&amp;gt; 后的第一个 &amp;lt;p&amp;gt;。
div+p { background-color: yellow; &amp;#39;} 后续兄弟选择器 后续兄弟选择器选择所有指定元素后的相邻兄弟元素。
如选择所有 &amp;lt;div&amp;gt; 后的所有相邻兄弟元素 &amp;lt;p&amp;gt;。
div ~ p { background-color: yellow; } </description>
    </item>
    
    <item>
      <title>选择器的优先级</title>
      <link>https://www.nicecorn.com/posts/css/%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/css/%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>浏览器通过优先级来判断哪些属性值与一个元素最为相关，从而在该元素上应用这些属性值。
选择器类型 以下的选择器类型的优先级递减：
ID 选择器（如 #example）。 类选择器（如 .example），属性选择器（如 [type=&amp;quot;redio&amp;quot;]）和伪类（如 :hover）。 类型选择器（如 h1）和伪元素（如 ::before）。 通配选择符（*）、关系选择符（+, &amp;gt;, ~, -, ||）和否定伪类（:not()）对优先级没有影响。然而，在 :not() 内部声明的选择器会影响优先级。
给元素添加的内联样式总是会覆盖外部样式表的任何样式，因此可看作是最高的优先级。
!important 例外规则 在一个样式声明中使用一个 !important 规则时，此声明将覆盖任何其他声明。使用 !important 是一个坏习惯，应该尽量避免，因为这破坏了样式表中的固有级联规则，使得调试变得困难。当两条相互冲突的带有 !important 规则的声明被应用到相同的元素上时，拥有更大优先级的声明将会被采用。
注意：
一定要优先考虑使用样式规则的优先级来解决问题而不是 !important。 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important。 永远不在全站范围中的 CSS 中使用 !important。 与其使用 !important，不如：
更好地利用 CSS 级联属性。 使用更具体的规则。在选择的元素之前，增加一个或多个其他元素，使选择器变得更加具体，并获得更高的优先级。 当没有其他要指定的内容时，可以复制简单的选择器以增加特异性。 什么情况下使用 !important：
覆盖内联样式。 覆盖优先级高的选择器。 </description>
    </item>
    
    <item>
      <title>基于 Docker 部署极简服务</title>
      <link>https://www.nicecorn.com/posts/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/2.-%E5%9F%BA%E4%BA%8E-docker-%E9%83%A8%E7%BD%B2%E6%9E%81%E7%AE%80%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/2.-%E5%9F%BA%E4%BA%8E-docker-%E9%83%A8%E7%BD%B2%E6%9E%81%E7%AE%80%E6%9C%8D%E5%8A%A1/</guid>
      <description>上文我们部署了一个简单的静态资源服务器。前端流行的部署方案都是使用 Docker 进行部署。这篇文章我们就使用 Docker 将该服务容器化。
将资源服务化 先借助一个工具 serve 将静态资源服务化。
pnpm add serve 通过 npm scripts 把 serve 命令封装成 npm start。
&amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;serve .&amp;#34; } 执行 pnpm start，serve 服务默认运行在 3000 端口，打开浏览器验证服务正常运行。
Dockerfile 一般来说，根据以下步骤可以将脚本命令转化为 Dockerfile。
选择一个基础镜像。在 Docker Hub 中查找我们需要的镜像。我们的服务基于 node 部署，因此我们选择 node:18-alpine3.15 作为基础镜像。该镜像基于 alpine 制作，内置了 node、npm、yarn 等运行环境。 将以上的脚本命令放在 RUN 命令中。 启动服务命令放在 CMD 命令中。 node.dockerfile 文件如下：
# 选择一个基础镜像 FROM node:18-alpine # 设置工作目录，以下 RUN/CMD 命令都在该目录下执行 WORKDIR /code # 把根目录下的文件置于镜像中 ADD . /code # 安装依赖 RUN yarn # 开放端口为 3000 EXPOSE 3000 # 启动 node 服务 CMD npm start 构建镜像 接下来使用 docker build 命令基于 dockerfile 构建镜像。</description>
    </item>
    
    <item>
      <title>箭头函数</title>
      <link>https://www.nicecorn.com/posts/javascript/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</guid>
      <description>箭头函数没有「this」 箭头函数没有 this，如果访问 this，则会从外部获取。
let group = { title: &amp;#39;Our Group&amp;#39;, students: [&amp;#39;John&amp;#39;, &amp;#39;Pete&amp;#39;, &amp;#39;Alice&amp;#39;], showList() { this.students.forEach((student) =&amp;gt; console.log(this.title + &amp;#39;: &amp;#39; + student), ); }, }; group.showList(); // Our Group: John // Our Group: Pete // Our Group: Alice 因为 foreach 使用了箭头函数，所以其中的 this.title 其实就是外部的 group.title。
如果使用正常的函数定义，那么 title 会为 undefined：
let group = { title: &amp;#39;Our Group&amp;#39;, students: [&amp;#39;John&amp;#39;, &amp;#39;Pete&amp;#39;, &amp;#39;Alice&amp;#39;], showList() { this.students.forEach(function (student) { console.log(this.title + &amp;#39;: &amp;#39; + student); }); }, }; group.</description>
    </item>
    
  </channel>
</rss>
