<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on Corn Park</title>
    <link>https://www.nicecorn.com/tags/javascript/</link>
    <description>Recent content in JavaScript on Corn Park</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hant</language>
    <copyright>Corn Huang</copyright>
    <lastBuildDate>Mon, 25 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.nicecorn.com/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>闭包</title>
      <link>https://www.nicecorn.com/posts/javascript/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E9%97%AD%E5%8C%85/</guid>
      <description>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使是函数在当前词法作用域外执行。
下面这个例子，函数 bar 在作为返回值返回后，在自己定义的词法作用域之外执行。
function foo() { const a = &amp;#39;hello&amp;#39;; function bar() { console.log(a); } return bar; } const baz = foo(); baz(); // hello 应用 防抖与节流</description>
    </item>
    
    <item>
      <title>模块化</title>
      <link>https://www.nicecorn.com/posts/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description> CommonJS：主要是 Node.js 使用，通过 require 同步加载模块，exports 导出内容。 AMD：主要是浏览器端使用，通过 define 定义模块和依赖，require 异步加载模块。 CMD：主要是浏览器端使用，和 AMD 类似，通过 require 异步加载模块，exports 导出内容。 UMD：通用模块规范，是 CommonJS 和 AMD 的融合，是跨平台的解决方案。 ESM：官方模块化规范，现代浏览器原生支持，通过 import 异步加载模块，export 导出内容。 </description>
    </item>
    
    <item>
      <title>类和类继承</title>
      <link>https://www.nicecorn.com/posts/javascript/%E7%B1%BB%E5%92%8C%E7%B1%BB%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E7%B1%BB%E5%92%8C%E7%B1%BB%E7%BB%A7%E6%89%BF/</guid>
      <description>题目 要求写一个动物类，有速度和名字的属性；给两个方法，一个为跑，一个为停止。 要求写一个兔子子类，继承动物类；给一个方法为藏起来。 ES6 class Animal { constructor(name) { this.speed = 0; this.name = name; } run(speed) { this.speed = speed; console.log(`${this.name} 跑的时速为 ${this.speed}`); } stop() { this.speed = 0; console.log(`${this.name} 停止`); } } class Rabbit extends Animal { hide() { console.log(`${this.name} 藏起来了`); } } ES5 function Animal(name) { this.name = name; this.speed = 0; } Animal.prototype.run = function (speed) { console.log(`${this.name} 跑的时速为 ${this.speed}`); }; Animal.prototype.stop = function () { this.</description>
    </item>
    
    <item>
      <title>数组去重</title>
      <link>https://www.nicecorn.com/posts/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      <description>filter + Object function unique(array) { let container = {}; return array.filter((item) =&amp;gt; container.hasOwnProperty(item) ? false : (container[item] = true), ); } filter + indexOf function unique(array) { return array.filter((item, index) =&amp;gt; array.indexOf(item) === index); } Set function unique(array) { return [...new Set(array)]; } </description>
    </item>
    
    <item>
      <title>防抖与节流</title>
      <link>https://www.nicecorn.com/posts/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</guid>
      <description>防抖 debounce 基本概念 debounce(fn, timeout)
自最近触发一次后，延迟 timeout 时间调用 fn。
应用场景 调整页面的大小 验证表单时控制请求次数 防止表单多次提交 编写代码 假设一个场景，点击按钮后提交表单数据。为防止表单多次提交，设置点击按钮后延迟 2000ms 提交，自最近一次触发后再延迟提交。
debounce 函数中，接收两个参数，第一个参数为执行防抖的函数，第二个参数为防抖的延迟时间。将计时器记为 timer，每次执行函数之前清除之，则达到每次触发函数时都重新计时的效果。
在执行防抖的函数中执行 console.log(this)，发现其指向 Windows。这时我们可以使用 apply 来把 this 的指向改变。
const button = document.getElementById(&amp;#39;button&amp;#39;); function addOne() { console.log(&amp;#39;add one&amp;#39;); console.log(Date()); } function debounce(fn, timeout) { let timer; return function () { clearTimeout(timer); timer = setTimeout(() =&amp;gt; { fn.apply(this, arguments); }, timeout); }; } button.addEventListener(&amp;#39;click&amp;#39;, debounce(addOne, 2000)); 总而言之，防抖是在不断的操作中最终只执行一次的提高性能的方法。
节流 throttle 基本概念 throttle(fn, timeout)
每 timeout 时间内只调用一次 fn。</description>
    </item>
    
    <item>
      <title>箭头函数</title>
      <link>https://www.nicecorn.com/posts/javascript/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</guid>
      <description>箭头函数没有「this」 箭头函数没有 this，如果访问 this，则会从外部获取。
let group = { title: &amp;#39;Our Group&amp;#39;, students: [&amp;#39;John&amp;#39;, &amp;#39;Pete&amp;#39;, &amp;#39;Alice&amp;#39;], showList() { this.students.forEach((student) =&amp;gt; console.log(this.title + &amp;#39;: &amp;#39; + student), ); }, }; group.showList(); // Our Group: John // Our Group: Pete // Our Group: Alice 因为 foreach 使用了箭头函数，所以其中的 this.title 其实就是外部的 group.title。
如果使用正常的函数定义，那么 title 会为 undefined：
let group = { title: &amp;#39;Our Group&amp;#39;, students: [&amp;#39;John&amp;#39;, &amp;#39;Pete&amp;#39;, &amp;#39;Alice&amp;#39;], showList() { this.students.forEach(function (student) { console.log(this.title + &amp;#39;: &amp;#39; + student); }); }, }; group.</description>
    </item>
    
  </channel>
</rss>
