<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vue on Corn Park</title>
    <link>https://www.nicecorn.com/tags/vue/</link>
    <description>Recent content in Vue on Corn Park</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hant</language>
    <copyright>Corn Huang</copyright>
    <lastBuildDate>Mon, 20 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.nicecorn.com/tags/vue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算属性与方法、watch 的异同</title>
      <link>https://www.nicecorn.com/posts/vue/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95watch-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95watch-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>计算属性缓存 vs 方法 在 Vue 中，调用一个函数可能也会获得到和计算属性相同的结果。
当我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的。不同之处在于，计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。只要原变量不改变，无论访问多少次计算属性都会立即返回先前的计算结果，而不用重复执行 getter 函数。
这也意味着下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖：
const now = computed(() =&amp;gt; Date.now()); 相比之下，方法调用总是会在重渲染发生时再次执行函数。
什么情况下需要缓存？如果有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，会重复执行非常多次 list 的计算函数。然而这实际上没有必要。如果确定不需要缓存，那么也可以使用方法调用。
计算属性 vs 侦听器 计算属性允许我们声明性地计算推导值。然而，在有些情况下，为了应对一些状态的变化，我们需要运行些「副作用」：例如更改 DOM，或者根据异步操作地结果，去修改另一处的状态。</description>
    </item>
    
    <item>
      <title>生命周期钩子</title>
      <link>https://www.nicecorn.com/posts/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</guid>
      <description>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据帧听、编译模板、挂载实例到 DOM 以及数据改变时更新 DOM。在此过程中，它也会运行称为生命周期钩子的函数，让开发者有机会在特定阶段添加自己的代码。
注册周期钩子 例如，onMounted 钩子可以在组建完成初始渲染并创建 DOM 节点后运行代码。
&amp;lt;script setup&amp;gt; import { onMounted } from &amp;#39;vue&amp;#39; onMounted(() =&amp;gt; { console.log(`the component is now mounted.`); }) &amp;lt;/script&amp;gt; 还有一些其他的钩子，会在实例生命周期的不同阶段被调用，最常用的是 onMounted、onUpdated 和 onUnmounted。
当调用 onMounted 时，Vue 会自动将注册的回调函数与当前活动组件实例相关联。这要求钩子在组件设置时同步注册，请不要：
setTimeout(() =&amp;gt; { onMounted(() =&amp;gt; { // 这将不会正常工作 }); }, 100); onMounted() 也可以放在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup()。
生命周期图示 </description>
    </item>
    
    <item>
      <title>条件渲染</title>
      <link>https://www.nicecorn.com/posts/vue/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</guid>
      <description>v-if vs v-show v-if 真实地按照条件渲染，因为它确保条件区块内的事件监听器和子组件都会在切换时被销毁与重建。
v-if 是懒加载的，如果在初次渲染时条件值为 false，则不会做任何事，直到条件首次变为 true 时才会渲染。
v-show 则无论初始条件如何，元素始终会被渲染，仅作 CSS Class 的切换。
总结：v-if 在首次渲染时的切换成本比 v-show 更高。因此需要非常频繁切换时 v-show 会更好，而运行时不常改变的时候 v-if 更合适。
v-if vs v-for 当 v-if 和 v-for 位于同一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名：
&amp;lt;!-- 这会抛出一个错误，因为属性 todo 此时 没有在该实例上定义 --&amp;gt; &amp;lt;li v-for=&amp;#34;todo in todos&amp;#34; v-if=&amp;#34;!todo.isComplete&amp;#34;&amp;gt; {{ todo.name }} &amp;lt;/li&amp;gt; 当需要同时使用时，在外新包装一层 &amp;lt;template&amp;gt; 并在其上使用 v-for：
&amp;lt;template v-for=&amp;#34;todo in todos&amp;#34;&amp;gt; &amp;lt;li v-if=&amp;#34;!todo.isComplete&amp;#34;&amp;gt; {{ todo.name }} &amp;lt;/li&amp;gt; &amp;lt;/template&amp;gt; </description>
    </item>
    
  </channel>
</rss>
