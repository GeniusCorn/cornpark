<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on Corn Park</title>
    <link>https://www.nicecorn.com/tags/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on Corn Park</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hant</language>
    <copyright>Corn Huang</copyright>
    <lastBuildDate>Mon, 25 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.nicecorn.com/tags/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>闭包</title>
      <link>https://www.nicecorn.com/posts/javascript/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E9%97%AD%E5%8C%85/</guid>
      <description>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使是函数在当前词法作用域外执行。
下面这个例子，函数 bar 在作为返回值返回后，在自己定义的词法作用域之外执行。
function foo() { const a = &amp;#39;hello&amp;#39;; function bar() { console.log(a); } return bar; } const baz = foo(); baz(); // hello 应用 防抖与节流</description>
    </item>
    
    <item>
      <title>模块化</title>
      <link>https://www.nicecorn.com/posts/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description> CommonJS：主要是 Node.js 使用，通过 require 同步加载模块，exports 导出内容。 AMD：主要是浏览器端使用，通过 define 定义模块和依赖，require 异步加载模块。 CMD：主要是浏览器端使用，和 AMD 类似，通过 require 异步加载模块，exports 导出内容。 UMD：通用模块规范，是 CommonJS 和 AMD 的融合，是跨平台的解决方案。 ESM：官方模块化规范，现代浏览器原生支持，通过 import 异步加载模块，export 导出内容。 </description>
    </item>
    
    <item>
      <title>类和类继承</title>
      <link>https://www.nicecorn.com/posts/javascript/%E7%B1%BB%E5%92%8C%E7%B1%BB%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E7%B1%BB%E5%92%8C%E7%B1%BB%E7%BB%A7%E6%89%BF/</guid>
      <description>题目 要求写一个动物类，有速度和名字的属性；给两个方法，一个为跑，一个为停止。 要求写一个兔子子类，继承动物类；给一个方法为藏起来。 ES6 class Animal { constructor(name) { this.speed = 0; this.name = name; } run(speed) { this.speed = speed; console.log(`${this.name} 跑的时速为 ${this.speed}`); } stop() { this.speed = 0; console.log(`${this.name} 停止`); } } class Rabbit extends Animal { hide() { console.log(`${this.name} 藏起来了`); } } ES5 function Animal(name) { this.name = name; this.speed = 0; } Animal.prototype.run = function (speed) { console.log(`${this.name} 跑的时速为 ${this.speed}`); }; Animal.prototype.stop = function () { this.</description>
    </item>
    
    <item>
      <title>数组去重</title>
      <link>https://www.nicecorn.com/posts/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      <description>filter + Object function unique(array) { let container = {}; return array.filter((item) =&amp;gt; container.hasOwnProperty(item) ? false : (container[item] = true), ); } filter + indexOf function unique(array) { return array.filter((item, index) =&amp;gt; array.indexOf(item) === index); } Set function unique(array) { return [...new Set(array)]; } </description>
    </item>
    
    <item>
      <title>手写最简静态资源服务器</title>
      <link>https://www.nicecorn.com/posts/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/1.-%E6%89%8B%E5%86%99%E6%9C%80%E7%AE%80%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/1.-%E6%89%8B%E5%86%99%E6%9C%80%E7%AE%80%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>一个简单的网页 在开始部署一个静态资源服务器之前，我们需要先写一个简单的网页供浏览。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt; hello, world &amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; HTTP HTTP 即超文本传输协议，是一个用于传输超文本文档（例如 HTML）的应用层协议。客户端打开一个连接以发送请求，然后等待直到收到服务器响应。最简部署即客户端向服务器发送一个 HTML 文件请求，服务器响应一段 HTML 资源。
在浏览器中访问任意网页，可以自行查看网页的 HTTP 请求和响应报文。
最简静态资源服务器：字符串 作为前端，我们使用 node 来搭建静态资源服务。该服务中，监听 3000 端口，在响应体中返回上文的网页。
首先以字符串返回响应。
在 node 中，写服务端的最重要模块为 node:http。通过 node: 前缀，可以指明其为内部模块，避免 node 内置模块与第三方模块的命名冲突。
const http = require(&amp;#39;node:http&amp;#39;); 通过 http.createServer 可以向外提供 HTTP 服务。res.end() 可以设置 HTTP 报文的响应体。我们先简单响应一个字符串。
const server = http.</description>
    </item>
    
    <item>
      <title>计算属性与方法、watch 的异同</title>
      <link>https://www.nicecorn.com/posts/vue/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95watch-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95watch-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>计算属性缓存 vs 方法 在 Vue 中，调用一个函数可能也会获得到和计算属性相同的结果。
当我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的。不同之处在于，计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。只要原变量不改变，无论访问多少次计算属性都会立即返回先前的计算结果，而不用重复执行 getter 函数。
这也意味着下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖：
const now = computed(() =&amp;gt; Date.now()); 相比之下，方法调用总是会在重渲染发生时再次执行函数。
什么情况下需要缓存？如果有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，会重复执行非常多次 list 的计算函数。然而这实际上没有必要。如果确定不需要缓存，那么也可以使用方法调用。
计算属性 vs 侦听器 计算属性允许我们声明性地计算推导值。然而，在有些情况下，为了应对一些状态的变化，我们需要运行些「副作用」：例如更改 DOM，或者根据异步操作地结果，去修改另一处的状态。</description>
    </item>
    
    <item>
      <title>生命周期钩子</title>
      <link>https://www.nicecorn.com/posts/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</guid>
      <description>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据帧听、编译模板、挂载实例到 DOM 以及数据改变时更新 DOM。在此过程中，它也会运行称为生命周期钩子的函数，让开发者有机会在特定阶段添加自己的代码。
注册周期钩子 例如，onMounted 钩子可以在组建完成初始渲染并创建 DOM 节点后运行代码。
&amp;lt;script setup&amp;gt; import { onMounted } from &amp;#39;vue&amp;#39; onMounted(() =&amp;gt; { console.log(`the component is now mounted.`); }) &amp;lt;/script&amp;gt; 还有一些其他的钩子，会在实例生命周期的不同阶段被调用，最常用的是 onMounted、onUpdated 和 onUnmounted。
当调用 onMounted 时，Vue 会自动将注册的回调函数与当前活动组件实例相关联。这要求钩子在组件设置时同步注册，请不要：
setTimeout(() =&amp;gt; { onMounted(() =&amp;gt; { // 这将不会正常工作 }); }, 100); onMounted() 也可以放在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup()。
生命周期图示 </description>
    </item>
    
    <item>
      <title>条件渲染</title>
      <link>https://www.nicecorn.com/posts/vue/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/vue/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</guid>
      <description>v-if vs v-show v-if 真实地按照条件渲染，因为它确保条件区块内的事件监听器和子组件都会在切换时被销毁与重建。
v-if 是懒加载的，如果在初次渲染时条件值为 false，则不会做任何事，直到条件首次变为 true 时才会渲染。
v-show 则无论初始条件如何，元素始终会被渲染，仅作 CSS Class 的切换。
总结：v-if 在首次渲染时的切换成本比 v-show 更高。因此需要非常频繁切换时 v-show 会更好，而运行时不常改变的时候 v-if 更合适。
v-if vs v-for 当 v-if 和 v-for 位于同一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名：
&amp;lt;!-- 这会抛出一个错误，因为属性 todo 此时 没有在该实例上定义 --&amp;gt; &amp;lt;li v-for=&amp;#34;todo in todos&amp;#34; v-if=&amp;#34;!todo.isComplete&amp;#34;&amp;gt; {{ todo.name }} &amp;lt;/li&amp;gt; 当需要同时使用时，在外新包装一层 &amp;lt;template&amp;gt; 并在其上使用 v-for：
&amp;lt;template v-for=&amp;#34;todo in todos&amp;#34;&amp;gt; &amp;lt;li v-if=&amp;#34;!todo.isComplete&amp;#34;&amp;gt; {{ todo.name }} &amp;lt;/li&amp;gt; &amp;lt;/template&amp;gt; </description>
    </item>
    
    <item>
      <title>防抖与节流</title>
      <link>https://www.nicecorn.com/posts/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</guid>
      <description>防抖 debounce 基本概念 debounce(fn, timeout)
自最近触发一次后，延迟 timeout 时间调用 fn。
应用场景 调整页面的大小 验证表单时控制请求次数 防止表单多次提交 编写代码 假设一个场景，点击按钮后提交表单数据。为防止表单多次提交，设置点击按钮后延迟 2000ms 提交，自最近一次触发后再延迟提交。
debounce 函数中，接收两个参数，第一个参数为执行防抖的函数，第二个参数为防抖的延迟时间。将计时器记为 timer，每次执行函数之前清除之，则达到每次触发函数时都重新计时的效果。
在执行防抖的函数中执行 console.log(this)，发现其指向 Windows。这时我们可以使用 apply 来把 this 的指向改变。
const button = document.getElementById(&amp;#39;button&amp;#39;); function addOne() { console.log(&amp;#39;add one&amp;#39;); console.log(Date()); } function debounce(fn, timeout) { let timer; return function () { clearTimeout(timer); timer = setTimeout(() =&amp;gt; { fn.apply(this, arguments); }, timeout); }; } button.addEventListener(&amp;#39;click&amp;#39;, debounce(addOne, 2000)); 总而言之，防抖是在不断的操作中最终只执行一次的提高性能的方法。
节流 throttle 基本概念 throttle(fn, timeout)
每 timeout 时间内只调用一次 fn。</description>
    </item>
    
    <item>
      <title>基于 Docker 部署极简服务</title>
      <link>https://www.nicecorn.com/posts/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/2.-%E5%9F%BA%E4%BA%8E-docker-%E9%83%A8%E7%BD%B2%E6%9E%81%E7%AE%80%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/2.-%E5%9F%BA%E4%BA%8E-docker-%E9%83%A8%E7%BD%B2%E6%9E%81%E7%AE%80%E6%9C%8D%E5%8A%A1/</guid>
      <description>上文我们部署了一个简单的静态资源服务器。前端流行的部署方案都是使用 Docker 进行部署。这篇文章我们就使用 Docker 将该服务容器化。
将资源服务化 先借助一个工具 serve 将静态资源服务化。
pnpm add serve 通过 npm scripts 把 serve 命令封装成 npm start。
&amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;serve .&amp;#34; } 执行 pnpm start，serve 服务默认运行在 3000 端口，打开浏览器验证服务正常运行。
Dockerfile 一般来说，根据以下步骤可以将脚本命令转化为 Dockerfile。
选择一个基础镜像。在 Docker Hub 中查找我们需要的镜像。我们的服务基于 node 部署，因此我们选择 node:18-alpine3.15 作为基础镜像。该镜像基于 alpine 制作，内置了 node、npm、yarn 等运行环境。 将以上的脚本命令放在 RUN 命令中。 启动服务命令放在 CMD 命令中。 node.dockerfile 文件如下：
# 选择一个基础镜像 FROM node:18-alpine # 设置工作目录，以下 RUN/CMD 命令都在该目录下执行 WORKDIR /code # 把根目录下的文件置于镜像中 ADD . /code # 安装依赖 RUN yarn # 开放端口为 3000 EXPOSE 3000 # 启动 node 服务 CMD npm start 构建镜像 接下来使用 docker build 命令基于 dockerfile 构建镜像。</description>
    </item>
    
    <item>
      <title>箭头函数</title>
      <link>https://www.nicecorn.com/posts/javascript/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.nicecorn.com/posts/javascript/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</guid>
      <description>箭头函数没有「this」 箭头函数没有 this，如果访问 this，则会从外部获取。
let group = { title: &amp;#39;Our Group&amp;#39;, students: [&amp;#39;John&amp;#39;, &amp;#39;Pete&amp;#39;, &amp;#39;Alice&amp;#39;], showList() { this.students.forEach((student) =&amp;gt; console.log(this.title + &amp;#39;: &amp;#39; + student), ); }, }; group.showList(); // Our Group: John // Our Group: Pete // Our Group: Alice 因为 foreach 使用了箭头函数，所以其中的 this.title 其实就是外部的 group.title。
如果使用正常的函数定义，那么 title 会为 undefined：
let group = { title: &amp;#39;Our Group&amp;#39;, students: [&amp;#39;John&amp;#39;, &amp;#39;Pete&amp;#39;, &amp;#39;Alice&amp;#39;], showList() { this.students.forEach(function (student) { console.log(this.title + &amp;#39;: &amp;#39; + student); }); }, }; group.</description>
    </item>
    
  </channel>
</rss>
